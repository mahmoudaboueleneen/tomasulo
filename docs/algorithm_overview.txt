Clock Cycle:
------------
-1. Read instructions and load them into Instruction Cache.


0. Fetch instruction from Instruction Cache into Instruction Queue.


1. (Issue & Read Operands)

   a) Before Issuing:
      Decode Instruction.
      If no Structural Hazard (availability of structure to carry out the operation/there's space in Buffer/Station)
      && In case of Load there is no Store manipulating the same address in the Buffers

      Then, 
       - Issue Instruction to its Buffer/Station,
       - Set the Buffer/Station to busy,
       - If not a Store, Update the Qi field in the Register file for the Instruction's Destination Register with the 
         tag of the Buffer/Station that the Instruction has been added to,
       - Add to a Hash Map ==> K: Tag of the Buffer/Station, V: Cycle Number that it's issued in.
      
   b) If Load instruction, skip the next check (as effective addresses are assumed already given so no need to check registers)
      Check Operand Registers in the Register File:
      If the Operand Registers are free (their Qi = 0) then copy the value to Vj/Vk.
      Else, copy the Buffer/Station tag responsible for this Operand from Qi in the Register File to Qj/Qk.


2. (Execute)

   For each Station, if it has Qj and Qk both equal 0, Execute (Decrement Cycles Left).
   For each Buffer, if memory is not busy, Execute (Decrement Cycles Left and set memory to busy).
   Each instruction keeps executing according to its required number of cycles to finish.
   If it's a Store, wait for the value to be stored to be ready before Executing.

   If instruction is finished, compute the result and add the {tag, value} to array of Finished Instructions.
   This array should be sorted based on the clock cycle number that the instruction was issued in.

3. (Write Result)

   If Finished Instructions Array is empty, 
      Return.

   Dequeue an instruction {tag, value} from the Finished Instructions Array
   And Write that instruction's result to the Bus.

   Find that instruction's station/buffer using the tag, and clear it, unset the busy status,
   and for buffers, unset the memory busy status.

   For each Station
      If the Station has Qj equals the tag published on the bus
         Set Qj to 0.
         Set Vj to the value from the bus.
      If the Station has Qk equals the tag published on the bus
         Set Qk to 0.
         Set Vk to the value from the bus.

   For each StoreBuffer
      If the StoreBuffer has Q equals the tag published on the bus
         Set Q to 0.
         Set V to the value from the bus.

   For each Register in the RegisterFile
      If the Register's Qi equals the tab published on the bus
         Set Qi to 0.
         Set content to the value from the bus.

   (Note: Load Buffers don't need updating as they only have effective address)

--------------------------------------------------------------------------------
vars to track: clockCycleNumber, cyclesLeft (for each instruction)
